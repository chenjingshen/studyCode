# JavaScript高级第六天

## 闭包练习
    setTimeout的执行时机
        所有的主任务的代码执行完毕之后，去检查所有的setTimeout回调函数，如果到时间了就执行

    用闭包来解决回调函数在调用的时候访问的是全局的变量
    在闭包中创建一个变量，来单独存储当前的回调函数需要的数据，
    在调用的时候就会去使用这个单独的数据，而不是去访问全局变量

    注册点击事件的时候
    点击事件在触发的时候访问的是全局的变量
    在闭包中创建一个变量，来单独存储当前的事件处理函数需要的数据，
    在调用的时候就会去使用这个单独的数据，而不是去访问全局变量


## 闭包缓存
    缓存：将常用的数据进行存储，以提升性能

    硬件缓存
    浏览器缓存
    CDN
    内存型数据库

    如何用闭包实现缓存
    1、写一个闭包在闭包中创建一个对象，用来做缓存的存储对象
    2、在闭包中创建一个对象，用来做缓存的存储对象
    3、在闭包中创建一个数组，用来存储换中的键
    4、返回一个函数，这个函数需要两个参数，一个是key 一个是value
    5、在返回的函数中,判断传入的value是否为undefined
    6、如果为Undefined 则表示是获取值，就直接返回在第一步创建的缓存对象中指定的键对应的值
    7、如果不为Undefined 则表示是设置值
    8、在缓存对象中设置指定的key的值为value
    9、把key加入存储key的数组
    10、判断key数组是不是超出了缓存大小限制
    11、如果超出限制，删除数组第一个元素（使用shift），获取到删除的key
    12、使用删除的key删除缓存对象中存储的值（delete）

## 使用缓存解决斐波那契数列的性能问题
    就是将已经计算过的数字缓存进一个数组中，下次再来访问的时候，直接在数组中进行查找，如果找到直接使用，如果没有找到，计算后将数字存入数组，然后返回该数字
## 沙箱模式
    沙箱模式就是一个封闭的独立的环境

    沙箱模式的基本模型
    (function(){
        //变量定义
        //逻辑代码
        //如果需要，向window对象添加成员，以暴露接口
    })()

    第三方框架
    插件
    独立的组件

## 函数的四种调用模式

函数模式
    this--->window
方法模式
    this---->调用方法的对象
构造函数模式
    this----->new出来的对象
    工厂模式
    寄生模式
上下文模式
    this----->指定的是谁就是谁
    call   函数.call(对象,arg1,arg2,arg3,...argn)
    apply  函数.apply(对象,数组)
        都可以用来改变this的指向为参数的第一个值
        call是使用单独的每一个参数来传参
        apply是使用数组进行传参的，这个数组在调用的时候，会被意义拆解，当做函数的每一个采参数

    call在函数的形参个数确定的情况下使用
    apply在函数的形参个数不确定的情况下使用

this指向不同